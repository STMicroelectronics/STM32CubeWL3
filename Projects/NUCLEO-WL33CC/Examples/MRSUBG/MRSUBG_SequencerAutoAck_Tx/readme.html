<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../../../../_htmresc/mini-st_2020.css" />
</head>
<body>
<div class="row">
<section id="mrsubg_sequencerautoack_tx-example-description"
class="col-sm-12 col-lg-4">
<h2><b>MRSUBG_SequencerAutoACK_Tx Example Description</b></h2>
<p>This example demonstrates how to use the STM32WL3 MRSUBG sequencer
feature to automatically transmit and receive packet acknowledgements
(ACKs).</p>
<p>The TX has two sequencer ActionConfigurations: WaitMsg and SendACK.
When a valid message is received, the sequencer automatically
transitions from the WaitMsg state to the SendACK state. After the ACK
is transmitted, an interrupt is triggered and the CPU resets the
sequencer back into the WaitMsg state.</p>
<p>The RX also has two sequencer ActionConfigurations: SendMsg and
WaitACK. After reset, the STM32WL3 first transmits a message containing
a counter value.</p>
<p>When the message transmission is done, the sequencer automatically
transitions from the SendMsg state to the WaitACK state, where this
device awaits an ACK from the other device.</p>
<p>Once that is received, an interrupt is triggered and the CPU resets
the sequencer back into the SendMsg state (after a short 50ms
delay).</p>
<p>TX and RX will “ping-pong” messages and ACKs back and forth until any
message / ACK is lost, at which point the exchange will stop.</p>
<h3 id="keywords"><b>Keywords</b></h3>
<p>MRSUBG, radio, sequencer</p>
<h3 id="directory-contents"><b>Directory contents</b></h3>
<ul>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Inc/stm32wl3x_nucleo_conf.h BSP
configuration file</li>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Inc/stm32wl3x_hal_conf.h HAL
Configuration file</li>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Inc/stm32wl3x_it.h Header for
stm32wl3x_it.c</li>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Inc/main.h Header file for
main.c</li>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Inc/stm32_assert.h Assert
description file</li>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Src/system_stm32wl3x.c STM32WL3x
system clock configuration file</li>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Src/stm32wl3x_it.c Interrupt
handlers</li>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Src/stm32wl3x_hal_msp.c HAL MSP
module</li>
<li>MRSUBG/MRSUBG_SequencerAutoACK_Tx/Src/main.c Main program</li>
</ul>
<h3 id="hardware-and-software-environment"><b>Hardware and Software
environment</b></h3>
<ul>
<li>This example runs on NUCLEO-WL33CC1 application board.</li>
<li>This example has been tested with STMicroelectronics NUCLEO-WL33CC1
application board and can be easily tailored to any other supported
device and development board.</li>
</ul>
<h3 id="how-to-use-it"><b>How to use it ?</b></h3>
<p>In order to make the program work, you must do the following :</p>
<ul>
<li>Open your preferred toolchain and load the workspace</li>
<li>Rebuild all files and load your image into target memory</li>
<li>Run the example</li>
</ul>
</section>
</div>
</body>
</html>
